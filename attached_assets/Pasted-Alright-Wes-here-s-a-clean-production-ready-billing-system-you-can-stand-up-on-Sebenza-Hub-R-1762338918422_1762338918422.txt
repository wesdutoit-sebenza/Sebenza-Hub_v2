Alright Wes â€” hereâ€™s a clean, **production-ready billing system** you can stand up on Sebenza Hub (Replit: Node/Express + PostgreSQL/Prisma + React). Itâ€™s built around a **feature-entitlement model**, so you can flip features on/off or set quotas per plan without touching product code.

---

# 1) The product model (3 groups Ã— 3 plans)

You already have three audiences with three tiers each (Free / Standard / Premium) and clear quantity limits. Treat each audience as a **product family** with its own plan catalog:

* **Individuals**: R0 / R99 / R299
* **Recruiters (Agencies)**: R0 / R799 / R1999
* **Corporate (Companies)**: R0 / R799 / R1999

Your limits matrix (from your PDF) becomes your â€œsource of truthâ€ for entitlements, e.g.:

* **Recruiter**: 2/50/Unlimited job posts; 10/100/Unlimited candidates; AI screening 50/Unlimited; fraud/spam AI on all tiers; tests/interview/job-desc agents 10/Unlimited/Unlimited. 
* **Corporate**: 1/5/Unlimited job posts; 5/50/Unlimited candidates; AI screening 5/Unlimited; fraud/spam AI on all tiers; tests/interview agents 2/Unlimited; job-desc agent on paid tiers. 
* **Individuals**: browse jobs on all tiers; Build CV 1/Unlimited/Unlimited; Upload CV (AI) on paid; Match Agent, WhatsApp apply, AI Interview Coach on paid; plus â€œReview my CV (AI)â€ & â€œCareer Path Visualizerâ€ on Premium. 

---

# 2) How to decide whatâ€™s billable

Use a simple rubric:

1. **Value driver?** If it reduces time-to-hire or meaningfully upgrades candidate experience (AI screening, fraud detection, interview scheduling, competency tests), make it billable.
2. **Marginal cost?** Anything that hits your tokens/compute (AI features, parsing, fraud) should be **metered or capped**.
3. **Lock-in/Network?** Core â€œtable stakesâ€ must stay free (basic browsing, profile, WhatsApp apply) to grow the network; advanced versions (AI, bulk, automation) are paid.

Billable **types** youâ€™ll use:

* **TOGGLE** (on/off): Fraud & Spam AI, WhatsApp Apply (for orgs), Job-Desc AI.
* **QUOTA** (reset monthly): Job posts, Candidates, AI Screenings, Tests, Interviews, CV builds, AI parses.
* **METERED** (pay-as-you-go add-ons): Optional overflow packs (e.g., +20 AI screenings).
* **ADD-ON**: One-off or recurring (e.g., extra seats, white-label pages, SSO).

---

# 3) Data model (Prisma)

```prisma
model User {
  id            String  @id @default(cuid())
  email         String  @unique
  name          String?
  accountType   AccountType // individual | recruiter | corporate
  orgId         String?
  org           Organization? @relation(fields: [orgId], references: [id])
}

model Organization {
  id           String @id @default(cuid())
  name         String
  type         OrgType // recruiter | corporate
  subscriptions Subscription[]
  members      User[]
}

model Plan {
  id            String @id @default(cuid())
  product       Product // individual | recruiter | corporate
  tier          Tier    // free | standard | premium
  priceCents    Int
  interval      Interval // monthly | annual
  features      FeatureEntitlement[]
}

model Feature {
  key           String @id // e.g. "job_posts", "ai_screenings", "fraud_ai"
  kind          FeatureKind // TOGGLE | QUOTA | METERED
  unit          String?     // e.g. "posts", "calls"
}

model FeatureEntitlement {
  id           String @id @default(cuid())
  planId       String
  featureKey   String
  enabled      Boolean      // for TOGGLE
  monthlyCap   Int?         // for QUOTA
  overageUnitCents Int?     // for METERED
  plan         Plan   @relation(fields: [planId], references: [id])
  feature      Feature @relation(fields: [featureKey], references: [key])
}

model Subscription {
  id            String @id @default(cuid())
  planId        String
  holderType    HolderType // user | org
  holderId      String     // User.id or Organization.id
  status        SubStatus
  currentPeriodStart DateTime
  currentPeriodEnd   DateTime
  netcashRef     String?   // link to Netcash profile/subscription
  plan           Plan      @relation(fields: [planId], references: [id])
}

model Usage {
  id            String @id @default(cuid())
  holderType    HolderType
  holderId      String
  featureKey    String
  periodStart   DateTime
  periodEnd     DateTime
  used          Int       // counts this period
  lastResetAt   DateTime
}

model PaymentEvent {
  id           String @id @default(cuid())
  gateway      String  // "netcash"
  eventId      String  @unique
  type         String  // e.g., subscription.activated
  payload      Json
  receivedAt   DateTime @default(now())
}
```

---

# 4) Feature-gate in code

Create a tiny **Feature Policy** service usable everywhere:

```ts
// server/services/entitlements.ts
export async function checkAllowed(holder: Holder, featureKey: string, inc=1) {
  const ent = await getEntitlement(holder, featureKey); // joins Subscription->Plan->FeatureEntitlement
  if (!ent) return { ok: false, reason: 'NO_PLAN' };

  if (ent.kind === 'TOGGLE') return { ok: !!ent.enabled };
  if (ent.kind === 'QUOTA') {
    const usage = await getUsage(holder, featureKey);
    return { ok: usage.used + inc <= (ent.monthlyCap ?? 0), remaining: (ent.monthlyCap ?? 0) - usage.used };
  }
  // METERED: always ok; bill later
  return { ok: true };
}

export async function consume(holder: Holder, featureKey: string, inc=1) {
  const allowed = await checkAllowed(holder, featureKey, inc);
  if (!allowed.ok) throw new Error('LIMIT_EXCEEDED');
  await incrementUsage(holder, featureKey, inc);
  return allowed;
}
```

**On every protected action** (create job post, run AI screen, book interview, parse CV, etc.), call `consume(...)`.
**On the frontend**, hide/disable with the same entitlements fetched via a light `/me/entitlements` endpoint to avoid surprises.

---

# 5) Mapping your plans â†’ entitlements

Seed script (example) â€” mirror the PDF:

```ts
// recruiter standard
grant('recruiter','standard','job_posts',{ kind:'QUOTA', monthlyCap:50 });
grant('recruiter','standard','candidates',{ kind:'QUOTA', monthlyCap:100 });
grant('recruiter','standard','ai_screenings',{ kind:'QUOTA', monthlyCap:Infinity }); // or very large
grant('recruiter','standard','fraud_ai',{ kind:'TOGGLE', enabled:true });
grant('recruiter','standard','competency_tests',{ kind:'QUOTA', monthlyCap:Infinity });
grant('recruiter','standard','interview_agent',{ kind:'QUOTA', monthlyCap:Infinity });
grant('recruiter','standard','jobdesc_ai',{ kind:'QUOTA', monthlyCap:Infinity });
```

Repeat with the **exact quantities from your sheet** for Recruiter, Corporate, Individual (as summarized above and cited).   

> **Tip:** for â€œUnlimitedâ€ set a high cap (e.g., 1e9) to avoid special-casing.

---

# 6) Trials, annual vs monthly, and upgrades

* Keep **Plan** rows per interval (monthly/annual). Upgrades/downgrades swap the `planId` on the active subscription and **prorate next cycle** (simplest: apply credit on next invoice).
* Trials: add `trialEndsAt` on `Subscription`. Before the date, status is `trialing` and price is R0.

---

# 7) Netcash integration (South Africa)

Netcash offers card/instant EFT/QR, and subscription/debit-order style billing. Youâ€™ll implement a **hosted checkout + webhooks** pattern (gateway-agnostic and secure):

**Server endpoints (Express):**

* `POST /billing/checkout` â†’ create a Netcash payment session (plan, interval, holder), store a pending `Subscription` with `status='pending'`, redirect URL from Netcash.
* `POST /billing/webhook` â†’ receive **verified** events (HMAC/signature), idempotently upsert `PaymentEvent`, then:

  * `subscription.activated` â†’ set `status='active'`, set `currentPeriodStart/End`, save `netcashRef`.
  * `payment.failed` â†’ set `status='past_due'` (grace period) and show in-app banner.
  * `subscription.canceled` â†’ set `status='canceled'`, keep data read-only.
* `POST /billing/portal` â†’ optionally redirect to Netcash customer portal (update card, cancel).

**Key practices (works with Netcash or any SA gateway):**

* **Verify signatures** on webhook requests; reject if invalid.
* **Idempotency**: store `eventId` in `PaymentEvent`; ignore duplicates.
* **Currency**: store cents as integers.
* **POPiA**: never log card/PAN; store only Netcash customer/subscription IDs.

> Youâ€™ll use Netcashâ€™s docs to fetch the exact field names for: session creation (amount, interval, description, reference), hosted-page return URLs, webhook headers for signature verification, and event types (activation, renewal, fail, cancel).

---

# 8) Usage resets & overage

* Nightly cron (or Replit scheduled task): reset `Usage.used=0` for each holder/feature at **period start**.
* If you want overage packs: create **add-on Products**; on purchase, credit an `extraAllowance` bucket in `Usage` for that period.

---

# 9) Frontend (React)

* **Pricing page** pulls your plan catalog from `/public/plans` so the site never drifts from the backend catalog.
* **Feature badges** (âœ… / ðŸ”’ / 50/50 used) reflect `entitlements` + live `usage`.
* **Upgrade CTAs** carry `product=...&tier=...&interval=...` to `/billing/checkout`.

---

# 10) Admin controls

Create a tiny admin screen:

* Edit **Plan** price, interval.
* Toggle **Feature** kind (TOGGLE/QUOTA/METERED).
* Edit **caps** per plan.
* Issue **courtesy credits** (bump `Usage` allowances).
* View **invoices/events** from Netcash (webhook log).

---

# 11) Security & reliability

* All billing endpoints behind CSRF and auth.
* Webhook endpoint on a separate route with an allow-list of Netcash IPs (if provided) + signature verification.
* **Audit log** every plan change, consumption, and admin override.
* Backups on your Postgres (Neon is great for Replit deployments).

---

## Quick implementation checklist (copy/paste to your tracker)

1. Prisma models above + seed script for **Features** and **Plans** (three product families Ã— three tiers Ã— monthly & annual).
2. Feature Policy service (`checkAllowed/consume`) and global middleware on sensitive actions.
3. `/public/plans`, `/me/entitlements`, `/billing/checkout`, `/billing/webhook`, `/billing/portal`.
4. React pricing page bound to `/public/plans`; upgrade buttons wire to checkout.
5. Netcash: create sandbox account, set webhook URL, store API keys in Replit Secrets, implement signature verify.
6. Cron for monthly usage reset; banner for past-due; downgrade grace (read-only).
7. Admin screen to edit entitlements & view PaymentEvent log.

---

If you want, I can generate the **Prisma schema + seed** for all nine plans with your exact caps (from the PDF) and stub the Express routes so you can paste straight into Replit.
