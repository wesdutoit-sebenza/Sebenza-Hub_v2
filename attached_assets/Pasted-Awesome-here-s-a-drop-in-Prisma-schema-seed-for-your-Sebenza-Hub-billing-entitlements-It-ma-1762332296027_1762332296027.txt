Awesome — here’s a drop-in **Prisma schema + seed** for your Sebenza Hub billing/entitlements. It matches the structure we discussed (catalog-driven plans, feature toggles/quotas/metered, org & individual holders), and pre-loads **all 9 plans** (Individuals / Recruiters / Corporate × Free / Standard / Premium) for **monthly & annual** with sensible caps aligned to your screenshots.

---

# `schema.prisma`

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum AccountType { individual recruiter corporate }
enum OrgType { recruiter corporate }
enum HolderType { user org }
enum SubStatus { pending trialing active past_due canceled }
enum Product { individual recruiter corporate }
enum Tier { free standard premium }
enum Interval { monthly annual }
enum FeatureKind { TOGGLE QUOTA METERED }

model User {
  id            String  @id @default(cuid())
  email         String  @unique
  name          String?
  accountType   AccountType
  orgId         String?
  org           Organization? @relation(fields: [orgId], references: [id])
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Organization {
  id            String @id @default(cuid())
  name          String
  type          OrgType
  members       User[]
  subscriptions Subscription[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Plan {
  id            String   @id @default(cuid())
  product       Product
  tier          Tier
  interval      Interval
  priceCents    Int
  currency      String   @default("ZAR")
  public        Boolean  @default(true)
  features      FeatureEntitlement[]
  subscriptions Subscription[]
  version       Int      @default(1) // bump when you change entitlements/pricing
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([product, tier, interval, version])
}

model Feature {
  key           String     @id      // e.g., "job_posts"
  name          String
  description   String
  kind          FeatureKind
  unit          String?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  entitlements  FeatureEntitlement[]
}

model FeatureEntitlement {
  id               String   @id @default(cuid())
  planId           String
  featureKey       String
  enabled          Boolean  @default(false) // for TOGGLE
  monthlyCap       Int?                  // for QUOTA
  overageUnitCents Int?                  // for METERED
  plan             Plan     @relation(fields: [planId], references: [id])
  feature          Feature  @relation(fields: [featureKey], references: [key])

  @@unique([planId, featureKey])
}

model Subscription {
  id                  String    @id @default(cuid())
  planId              String
  holderType          HolderType
  holderId            String
  status              SubStatus @default(pending)
  currentPeriodStart  DateTime? 
  currentPeriodEnd    DateTime?
  trialEndsAt         DateTime?
  cancelAtPeriodEnd   Boolean   @default(false)
  netcashRef          String?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  plan                Plan      @relation(fields: [planId], references: [id])

  @@index([holderType, holderId])
}

model Usage {
  id            String     @id @default(cuid())
  holderType    HolderType
  holderId      String
  featureKey    String
  periodStart   DateTime
  periodEnd     DateTime
  used          Int        @default(0)
  extraAllowance Int       @default(0) // add-on “packs”
  lastResetAt   DateTime   @default(now())

  @@unique([holderType, holderId, featureKey, periodStart, periodEnd])
}

model PaymentEvent {
  id        String   @id @default(cuid())
  gateway   String   // "netcash"
  eventId   String   @unique
  type      String
  payload   Json
  receivedAt DateTime @default(now())
}
```

---

# `prisma/seed.ts`

> Seed all features, plans (monthly + annual), and plan-feature entitlements.
> You can tweak caps/prices in one place and re-seed.

```ts
// prisma/seed.ts
import { PrismaClient, Interval, Product, Tier, FeatureKind } from '@prisma/client';
const prisma = new PrismaClient();

type GrantSpec =
  | { kind: 'TOGGLE'; enabled: boolean }
  | { kind: 'QUOTA'; monthlyCap: number }       // use 1e9 for "unlimited"
  | { kind: 'METERED'; overageUnitCents: number };

async function upsertFeature(key: string, name: string, description: string, kind: 'TOGGLE'|'QUOTA'|'METERED', unit?: string) {
  await prisma.feature.upsert({
    where: { key },
    update: { name, description, kind, unit },
    create: { key, name, description, kind, unit }
  });
}

async function upsertPlan(product: Product, tier: Tier, interval: Interval, priceCents: number) {
  return prisma.plan.upsert({
    where: { product_tier_interval_version: { product, tier, interval, version: 1 }},
    update: { priceCents },
    create: { product, tier, interval, priceCents, currency: 'ZAR', version: 1, public: true }
  });
}

async function grant(planId: string, featureKey: string, spec: GrantSpec) {
  const feature = await prisma.feature.findUnique({ where: { key: featureKey }});
  if (!feature) throw new Error(`Feature ${featureKey} missing`);
  const base = { planId, featureKey };
  if (spec.kind === 'TOGGLE') {
    await prisma.featureEntitlement.upsert({
      where: { planId_featureKey: { planId, featureKey } },
      create: { ...base, enabled: spec.enabled },
      update: { enabled: spec.enabled, monthlyCap: null, overageUnitCents: null }
    });
  } else if (spec.kind === 'QUOTA') {
    await prisma.featureEntitlement.upsert({
      where: { planId_featureKey: { planId, featureKey } },
      create: { ...base, monthlyCap: spec.monthlyCap, enabled: true },
      update: { monthlyCap: spec.monthlyCap, enabled: true, overageUnitCents: null }
    });
  } else {
    await prisma.featureEntitlement.upsert({
      where: { planId_featureKey: { planId, featureKey } },
      create: { ...base, overageUnitCents: spec.overageUnitCents, enabled: true },
      update: { overageUnitCents: spec.overageUnitCents, enabled: true }
    });
  }
}

const Z = (rands: number) => Math.round(rands * 100);
const INF = 1_000_000_000; // practical “unlimited”

async function main() {
  // 1) Catalog of features
  // ---- Shared org features
  await upsertFeature('job_posts', 'Job Posts', 'Number of active job postings per month', 'QUOTA', 'posts');
  await upsertFeature('candidates', 'Candidates', 'Number of candidate profiles/applications you can manage per month', 'QUOTA', 'candidates');
  await upsertFeature('ai_screenings', 'AI Screenings', 'Automated AI screening runs per month', 'QUOTA', 'runs');
  await upsertFeature('fraud_ai', 'Fraud & Spam AI', 'Automated fraud/spam detection for applications', 'TOGGLE');
  await upsertFeature('competency_tests', 'Competency Tests (AI)', 'AI-generated tests you can issue per month', 'QUOTA', 'tests');
  await upsertFeature('interview_agent', 'Interview Agent (AI)', 'Structured AI interview sessions per month', 'QUOTA', 'interviews');
  await upsertFeature('jobdesc_ai', 'Job Description Agent', 'Generate/refine job descriptions with AI', 'TOGGLE');
  await upsertFeature('whatsapp_apply_org', 'WhatsApp Apply (Org)', 'Enable WhatsApp-first application channel', 'TOGGLE');

  // ---- Individual features
  await upsertFeature('browse_jobs', 'Browse Jobs', 'Search & browse all public jobs', 'TOGGLE');
  await upsertFeature('cv_builder', 'Build CV', 'Create branded CVs in the builder', 'QUOTA', 'CVs');
  await upsertFeature('cv_upload_ai', 'Upload CV (AI Parse)', 'AI-powered CV parsing uploads', 'QUOTA', 'uploads');
  await upsertFeature('match_agent', 'Job Match Agent', 'AI matches your profile to relevant jobs', 'TOGGLE');
  await upsertFeature('whatsapp_apply_user', 'WhatsApp Apply', 'Apply to jobs via WhatsApp flow', 'TOGGLE');
  await upsertFeature('ai_interview_coach', 'AI Interview Coach', 'Practice interviews with AI coach', 'TOGGLE');
  await upsertFeature('cv_review_ai', 'Review my CV (AI)', 'Automated AI review suggestions for CVs', 'TOGGLE');
  await upsertFeature('career_visualizer', 'Career Path Visualizer', 'AI career roadmap visualization', 'TOGGLE');

  // 2) Create plans (monthly + annual)
  const planDefs: Array<{product: Product; tier: Tier; monthly: number; annual?: number;}> = [
    // Individuals
    { product: 'individual', tier: 'free',     monthly: Z(0),    annual: Z(0) },
    { product: 'individual', tier: 'standard', monthly: Z(99),   annual: Z(99*12) },
    { product: 'individual', tier: 'premium',  monthly: Z(299),  annual: Z(299*12) },
    // Recruiters
    { product: 'recruiter',  tier: 'free',     monthly: Z(0),    annual: Z(0) },
    { product: 'recruiter',  tier: 'standard', monthly: Z(799),  annual: Z(799*12) },
    { product: 'recruiter',  tier: 'premium',  monthly: Z(1999), annual: Z(1999*12) },
    // Corporate
    { product: 'corporate',  tier: 'free',     monthly: Z(0),    annual: Z(0) },
    { product: 'corporate',  tier: 'standard', monthly: Z(799),  annual: Z(799*12) },
    { product: 'corporate',  tier: 'premium',  monthly: Z(1999), annual: Z(1999*12) },
  ];

  const plans: Record<string, string> = {}; // key: `${product}-${tier}-${interval}` -> planId
  for (const def of planDefs) {
    const m = await upsertPlan(def.product as Product, def.tier as Tier, 'monthly', def.monthly);
    plans[`${def.product}-${def.tier}-monthly`] = m.id;
    const a = await upsertPlan(def.product as Product, def.tier as Tier, 'annual', def.annual ?? def.monthly*12);
    plans[`${def.product}-${def.tier}-annual`] = a.id;
  }

  // Helper to grant on both intervals
  const grantBoth = async (product: Product, tier: Tier, featureKey: string, spec: GrantSpec) => {
    await grant(plans[`${product}-${tier}-monthly`], featureKey, spec);
    await grant(plans[`${product}-${tier}-annual`], featureKey, spec);
  };

  // 3) Entitlements per product family

  // === RECRUITERS ===
  // Free
  await grantBoth('recruiter','free','job_posts',         { kind:'QUOTA',  monthlyCap: 2 });
  await grantBoth('recruiter','free','candidates',        { kind:'QUOTA',  monthlyCap: 10 });
  await grantBoth('recruiter','free','ai_screenings',     { kind:'QUOTA',  monthlyCap: 50 });
  await grantBoth('recruiter','free','fraud_ai',          { kind:'TOGGLE', enabled:true });
  await grantBoth('recruiter','free','competency_tests',  { kind:'QUOTA',  monthlyCap: 10 });
  await grantBoth('recruiter','free','interview_agent',   { kind:'QUOTA',  monthlyCap: 10 });
  await grantBoth('recruiter','free','jobdesc_ai',        { kind:'TOGGLE', enabled:false });
  await grantBoth('recruiter','free','whatsapp_apply_org',{ kind:'TOGGLE', enabled:true });

  // Standard
  await grantBoth('recruiter','standard','job_posts',         { kind:'QUOTA', monthlyCap: 50 });
  await grantBoth('recruiter','standard','candidates',        { kind:'QUOTA', monthlyCap: 100 });
  await grantBoth('recruiter','standard','ai_screenings',     { kind:'QUOTA', monthlyCap: INF });
  await grantBoth('recruiter','standard','fraud_ai',          { kind:'TOGGLE', enabled:true });
  await grantBoth('recruiter','standard','competency_tests',  { kind:'QUOTA', monthlyCap: INF });
  await grantBoth('recruiter','standard','interview_agent',   { kind:'QUOTA', monthlyCap: INF });
  await grantBoth('recruiter','standard','jobdesc_ai',        { kind:'TOGGLE', enabled:true });
  await grantBoth('recruiter','standard','whatsapp_apply_org',{ kind:'TOGGLE', enabled:true });

  // Premium
  await grantBoth('recruiter','premium','job_posts',         { kind:'QUOTA', monthlyCap: INF });
  await grantBoth('recruiter','premium','candidates',        { kind:'QUOTA', monthlyCap: INF });
  await grantBoth('recruiter','premium','ai_screenings',     { kind:'QUOTA', monthlyCap: INF });
  await grantBoth('recruiter','premium','fraud_ai',          { kind:'TOGGLE', enabled:true });
  await grantBoth('recruiter','premium','competency_tests',  { kind:'QUOTA', monthlyCap: INF });
  await grantBoth('recruiter','premium','interview_agent',   { kind:'QUOTA', monthlyCap: INF });
  await grantBoth('recruiter','premium','jobdesc_ai',        { kind:'TOGGLE', enabled:true });
  await grantBoth('recruiter','premium','whatsapp_apply_org',{ kind:'TOGGLE', enabled:true });

  // === CORPORATE ===
  // Free
  await grantBoth('corporate','free','job_posts',        { kind:'QUOTA', monthlyCap: 1 });
  await grantBoth('corporate','free','candidates',       { kind:'QUOTA', monthlyCap: 5 });
  await grantBoth('corporate','free','ai_screenings',    { kind:'QUOTA', monthlyCap: 5 });
  await grantBoth('corporate','free','fraud_ai',         { kind:'TOGGLE', enabled:true });
  await grantBoth('corporate','free','competency_tests', { kind:'QUOTA', monthlyCap: 2 });
  await grantBoth('corporate','free','interview_agent',  { kind:'QUOTA', monthlyCap: 2 });
  await grantBoth('corporate','free','jobdesc_ai',       { kind:'TOGGLE', enabled:false });
  await grantBoth('corporate','free','whatsapp_apply_org',{ kind:'TOGGLE', enabled:true });

  // Standard
  await grantBoth('corporate','standard','job_posts',        { kind:'QUOTA', monthlyCap: 5 });
  await grantBoth('corporate','standard','candidates',       { kind:'QUOTA', monthlyCap: 50 });
  await grantBoth('corporate','standard','ai_screenings',    { kind:'QUOTA', monthlyCap: INF });
  await grantBoth('corporate','standard','fraud_ai',         { kind:'TOGGLE', enabled:true });
  await grantBoth('corporate','standard','competency_tests', { kind:'QUOTA', monthlyCap: INF });
  await grantBoth('corporate','standard','interview_agent',  { kind:'QUOTA', monthlyCap: INF });
  await grantBoth('corporate','standard','jobdesc_ai',       { kind:'TOGGLE', enabled:true });
  await grantBoth('corporate','standard','whatsapp_apply_org',{ kind:'TOGGLE', enabled:true });

  // Premium
  await grantBoth('corporate','premium','job_posts',        { kind:'QUOTA', monthlyCap: INF });
  await grantBoth('corporate','premium','candidates',       { kind:'QUOTA', monthlyCap: INF });
  await grantBoth('corporate','premium','ai_screenings',    { kind:'QUOTA', monthlyCap: INF });
  await grantBoth('corporate','premium','fraud_ai',         { kind:'TOGGLE', enabled:true });
  await grantBoth('corporate','premium','competency_tests', { kind:'QUOTA', monthlyCap: INF });
  await grantBoth('corporate','premium','interview_agent',  { kind:'QUOTA', monthlyCap: INF });
  await grantBoth('corporate','premium','jobdesc_ai',       { kind:'TOGGLE', enabled:true });
  await grantBoth('corporate','premium','whatsapp_apply_org',{ kind:'TOGGLE', enabled:true });

  // === INDIVIDUALS ===
  // Free
  await grantBoth('individual','free','browse_jobs',        { kind:'TOGGLE', enabled: true });
  await grantBoth('individual','free','cv_builder',         { kind:'QUOTA',  monthlyCap: 1 });
  await grantBoth('individual','free','cv_upload_ai',       { kind:'QUOTA',  monthlyCap: 0 }); // off on Free
  await grantBoth('individual','free','match_agent',        { kind:'TOGGLE', enabled: false });
  await grantBoth('individual','free','whatsapp_apply_user',{ kind:'TOGGLE', enabled: false });
  await grantBoth('individual','free','ai_interview_coach', { kind:'TOGGLE', enabled: false });
  await grantBoth('individual','free','cv_review_ai',       { kind:'TOGGLE', enabled: false });
  await grantBoth('individual','free','career_visualizer',  { kind:'TOGGLE', enabled: false });

  // Standard
  await grantBoth('individual','standard','browse_jobs',        { kind:'TOGGLE', enabled: true });
  await grantBoth('individual','standard','cv_builder',         { kind:'QUOTA',  monthlyCap: INF });
  await grantBoth('individual','standard','cv_upload_ai',       { kind:'QUOTA',  monthlyCap: INF });
  await grantBoth('individual','standard','match_agent',        { kind:'TOGGLE', enabled: true });
  await grantBoth('individual','standard','whatsapp_apply_user',{ kind:'TOGGLE', enabled: true });
  await grantBoth('individual','standard','ai_interview_coach', { kind:'TOGGLE', enabled: true });
  await grantBoth('individual','standard','cv_review_ai',       { kind:'TOGGLE', enabled: false });
  await grantBoth('individual','standard','career_visualizer',  { kind:'TOGGLE', enabled: false });

  // Premium
  await grantBoth('individual','premium','browse_jobs',        { kind:'TOGGLE', enabled: true });
  await grantBoth('individual','premium','cv_builder',         { kind:'QUOTA',  monthlyCap: INF });
  await grantBoth('individual','premium','cv_upload_ai',       { kind:'QUOTA',  monthlyCap: INF });
  await grantBoth('individual','premium','match_agent',        { kind:'TOGGLE', enabled: true });
  await grantBoth('individual','premium','whatsapp_apply_user',{ kind:'TOGGLE', enabled: true });
  await grantBoth('individual','premium','ai_interview_coach', { kind:'TOGGLE', enabled: true });
  await grantBoth('individual','premium','cv_review_ai',       { kind:'TOGGLE', enabled: true });
  await grantBoth('individual','premium','career_visualizer',  { kind:'TOGGLE', enabled: true });

  console.log('Seed complete ✅');
}

main().catch(e => {
  console.error(e);
  process.exit(1);
}).finally(async () => {
  await prisma.$disconnect();
});
```

---

## How to run on Replit (or locally)

```bash
# 1) Install prisma & client
npm i -D prisma
npm i @prisma/client

# 2) Initialize if needed
npx prisma init

# 3) Put the schema above in prisma/schema.prisma

# 4) Migrate & generate
npx prisma migrate dev -n "init_billing"

# 5) Add seed script to package.json
# "prisma": { "seed": "ts-node --transpile-only prisma/seed.ts" }
npm i -D ts-node typescript

# 6) Seed
npx prisma db seed
```

---

## Using entitlements in your app

```ts
// services/entitlements.ts
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();

export async function getActivePlanFor(holderType:'user'|'org', holderId:string){
  return prisma.subscription.findFirst({
    where: { holderType: holderType === 'user' ? 'user':'org', holderId, status: 'active' },
    include: { plan: { include: { features: { include: { feature: true }}}}}
  });
}

export async function checkAllowed(holderType:'user'|'org', holderId:string, featureKey:string, inc=1){
  const sub = await getActivePlanFor(holderType, holderId);
  if(!sub) return { ok:false, reason:'NO_SUBSCRIPTION' };
  const ent = sub.plan.features.find(f => f.featureKey === featureKey);
  if(!ent) return { ok:false, reason:'NOT_IN_PLAN' };

  const kind = ent.feature.kind;
  if(kind === 'TOGGLE') return { ok: !!ent.enabled };

  if(kind === 'QUOTA'){
    const now = new Date();
    const usage = await prisma.usage.findFirst({
      where: { holderType: holderType==='user'?'user':'org', holderId, featureKey, periodStart: { lte: now }, periodEnd: { gte: now } }
    });
    const used = usage?.used ?? 0;
    const cap = ent.monthlyCap ?? 0;
    const extra = usage?.extraAllowance ?? 0;
    const allowed = used + inc <= (cap + extra);
    return { ok: allowed, remaining: (cap + extra) - used };
  }

  // METERED: allow; invoice later
  return { ok: true };
}

export async function consume(holderType:'user'|'org', holderId:string, featureKey:string, inc=1){
  const check = await checkAllowed(holderType, holderId, featureKey, inc);
  if(!check.ok) throw new Error('LIMIT_EXCEEDED');
  const now = new Date();
  // Compute current period boundaries from subscription
  // (simplest: use sub.currentPeriodStart/End)
  const sub = await getActivePlanFor(holderType, holderId);
  if(!sub?.currentPeriodStart || !sub?.currentPeriodEnd) return check;

  await prisma.usage.upsert({
    where: {
      holderType_holderId_featureKey_periodStart_periodEnd: {
        holderType: holderType==='user'?'user':'org',
        holderId, featureKey,
        periodStart: sub.currentPeriodStart, periodEnd: sub.currentPeriodEnd
      }
    },
    update: { used: { increment: inc } },
    create: {
      holderType: holderType==='user'?'user':'org',
      holderId, featureKey,
      periodStart: sub.currentPeriodStart, periodEnd: sub.currentPeriodEnd,
      used: inc
    }
  });

  return check;
}
```

---

## Notes & next steps

* **Adjust caps/prices**: Everything is seeded in one place — update numbers in `seed.ts` and re-seed (or write a small admin UI to edit entitlements live).
* **Annual discounts**: Right now annual is `12×` monthly. Change `annual` in `planDefs` to apply a discount (e.g., `Z(99*12*0.9)`).
* **Grandfathering**: When you change pricing or caps, increment `Plan.version` and create a new row; keep old subscribers on the old version.
* **Netcash**: You’ll map each `Plan` to a Netcash product/price and store Netcash’s IDs alongside `Plan` (add `netcashPriceId` if you want).
* **Trials**: Populate `trialEndsAt` on `Subscription` at checkout, enforce in access checks.

If you want, I’ll also paste in a **ready Express router** for `/billing/checkout`, `/billing/webhook`, and a tiny `/public/plans` + `/me/entitlements` API so your React pricing page and lock/upgrade modals are wired in immediately.
