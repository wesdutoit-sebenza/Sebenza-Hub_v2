// worker.screening.ts
import { Worker, Job } from "bullmq";
import { connection } from "./queue.js";
import pg from "pg";
import { OpenAI } from "openai";

const pool = new pg.Pool({ connectionString: process.env.DATABASE_URL });
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

const SYSTEM_PROMPT = process.env.SCREENING_SYSTEM_PROMPT; // the System Prompt I gave you earlier

new Worker("screening", async (job: Job) => {
  if (job.name === "seed-role-screenings") {
    const { roleId } = job.data;

    // Prefilter: pick top 300 candidates by semantic similarity (or latest 500 fallback)
    const { rows: roleRows } = await pool.query("SELECT * FROM roles WHERE id=$1", [roleId]);
    if (!roleRows.length) return;
    const role = roleRows[0];

    // Compute embedding for role search string
    const searchText = [
      role.job_title,
      role.job_description,
      (role.must_have_skills || []).join(", "),
      role.location_city || "", role.work_type || ""
    ].join("\n");

    let emb: number[] | null = null;
    try {
      const e = await openai.embeddings.create({ model: "text-embedding-3-small", input: searchText });
      emb = e.data[0].embedding as unknown as number[];
    } catch {}

    let candidates;
    if (emb) {
      candidates = (await pool.query(
        `SELECT c.id
         FROM candidate_embeddings ce
         JOIN candidates c ON c.id = ce.candidate_id
         ORDER BY ce.embedding <=> $1
         LIMIT 300`,
        [emb]
      )).rows;
    } else {
      candidates = (await pool.query(
        `SELECT id FROM candidates ORDER BY created_at DESC LIMIT 300`
      )).rows;
    }

    for (const c of candidates) {
      await job.queue.add("screen", { roleId, candidateId: c.id });
    }
    return;
  }

  if (job.name === "screen") {
    const { roleId, candidateId } = job.data;

    // Fetch role & candidate profile (normalized)
    const { rows: rRows } = await pool.query("SELECT * FROM roles WHERE id=$1", [roleId]);
    const { rows: cRows } = await pool.query(`
      SELECT c.*, 
        COALESCE((
          SELECT json_agg(e) FROM (
            SELECT title, company, industry, location, start_date, end_date, is_current, bullets
            FROM experiences WHERE candidate_id = c.id
          ) e
        ), '[]'::json) AS experience,
        COALESCE((
          SELECT json_agg(ed) FROM (
            SELECT institution, qualification, location, grad_date
            FROM education WHERE candidate_id = c.id
          ) ed
        ), '[]'::json) AS education,
        COALESCE((
          SELECT json_agg(cert) FROM (
            SELECT name, issuer, year FROM certifications WHERE candidate_id = c.id
          ) cert
        ), '[]'::json) AS certifications,
        COALESCE((
          SELECT json_agg(p) FROM (
            SELECT name, what, impact, link FROM projects WHERE candidate_id = c.id
          ) p
        ), '[]'::json) AS projects,
        COALESCE((
          SELECT json_agg(a) FROM (
            SELECT name, by_whom AS "by", year, note FROM awards WHERE candidate_id = c.id
          ) a
        ), '[]'::json) AS awards,
        COALESCE((
          SELECT json_object_agg(kind, array_agg(s.name))
          FROM candidate_skills cs
          JOIN skills s ON s.id = cs.skill_id
          WHERE cs.candidate_id = c.id
          GROUP BY kind
        ), '{"technical":[],"tools":[],"soft":[]}') AS skills_json
      FROM candidates c
      WHERE c.id=$1
    `, [candidateId]);

    if (!rRows.length || !cRows.length) return;
    const role = rRows[0];
    const cand = cRows[0];

    // Build the user message for the LLM
    const userMsg = {
      role: {
        job_title: role.job_title,
        job_description: role.job_description,
        seniority: role.seniority,
        employment_type: role.employment_type,
        location: { city: role.location_city, country: role.location_country, work_type: role.work_type },
        must_have_skills: role.must_have_skills || [],
        nice_to_have_skills: role.nice_to_have_skills || [],
        salary_range: { min: role.salary_min, max: role.salary_max, currency: role.salary_currency || "ZAR" },
        knockouts: role.knockouts || [],
        weights: role.weights || undefined
      },
      candidate: {
        full_name: cand.full_name,
        contact: { email: cand.email, phone: cand.phone, city: cand.city, country: cand.country },
        headline: cand.headline,
        skills: cand.skills_json,
        experience: cand.experience,
        education: cand.education,
        certifications: cand.certifications,
        projects: cand.projects,
        awards: cand.awards,
        work_authorization: cand.work_authorization,
        availability: cand.availability,
        salary_expectation: cand.salary_expectation,
        links: cand.links
      }
    };

    // Call LLM (Screening Agent) — return one ranking item
    let llmScore: any | null = null;
    try {
      const completion = await openai.chat.completions.create({
        model: "gpt-5.1-mini",
        temperature: 0,
        messages: [
          { role: "system", content: SYSTEM_PROMPT },
          { role: "user", content: "Evaluate this single candidate against the role. Return only a JSON object matching the 'ranking' item in OUTPUT_SCHEMA (one item, no array)." },
          { role: "user", content: JSON.stringify(userMsg) }
        ]
      });
      llmScore = JSON.parse(completion.choices[0].message.content!);
    } catch (e) {
      // fall back to deterministic scorer
      llmScore = scoreDeterministic(role, cand);
    }

    // Upsert into screenings
    await pool.query(
      `INSERT INTO screenings(role_id, candidate_id, score_total, score_breakdown,
                              must_haves_satisfied, missing_must_haves, knockout, reasons, flags)
       VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)
       ON CONFLICT (role_id, candidate_id)
       DO UPDATE SET score_total=EXCLUDED.score_total,
         score_breakdown=EXCLUDED.score_breakdown,
         must_haves_satisfied=EXCLUDED.must_haves_satisfied,
         missing_must_haves=EXCLUDED.missing_must_haves,
         knockout=EXCLUDED.knockout,
         reasons=EXCLUDED.reasons,
         flags=EXCLUDED.flags,
         created_at=now()`,
      [
        roleId,
        candidateId,
        llmScore.score_total ?? 0,
        llmScore.score_breakdown ?? {},
        llmScore.must_haves_satisfied ?? [],
        llmScore.missing_must_haves ?? [],
        llmScore.knockout ?? { is_ko: false, reasons: [] },
        llmScore.reasons ?? [],
        llmScore.flags ?? { red: [], yellow: [] }
      ]
    );
  }
}, { connection });

// Simple deterministic backup (very light example)
function scoreDeterministic(role: any, cand: any) {
  const weights = role.weights || { skills:35, experience:25, achievements:15, education:10, location_auth:10, salary_availability:5 };
  const ch = (v:number)=>Math.max(0, Math.min(100, v));

  const skills = new Set<string>([
    ...(cand.skills_json?.technical||[]),
    ...(cand.skills_json?.tools||[]),
    ...(cand.skills_json?.soft||[])
  ].map((s:string)=>s.toLowerCase()));

  const must = (role.must_have_skills||[]).map((s:string)=>s.toLowerCase());
  const nice = (role.nice_to_have_skills||[]).map((s:string)=>s.toLowerCase());
  const haveMust = must.filter((m:string)=>skills.has(m));
  const haveNice = nice.filter((n:string)=>skills.has(n));
  const skillsScore = ch((haveMust.length*100/(must.length||1)) * 0.8 + (haveNice.length*100/((nice.length||1))) * 0.2);

  // crude experience heuristic
  const expYears = estimateYears(cand.experience||[]);
  const expScore = ch(Math.min(100, (expYears/ (role.seniority?.toLowerCase().includes("senior")?7:3))*100));

  // achievements: count numeric tokens in bullets
  const achCount = (cand.experience||[]).flatMap((e:any)=>e.bullets||[]).join(" ").match(/\b(\d+%?|R\d+[kmb]?)/gi)?.length || 0;
  const achScore = ch(Math.min(100, achCount*12));

  const eduScore = 60 + Math.min(40, (cand.education||[]).length*20);
  const locScore = (role.location_city && cand.city && role.location_city.toLowerCase()===cand.city.toLowerCase()) ? 100 : 60;
  const salScore = 70; // unknown → neutral

  const total =
    skillsScore*(weights.skills/100) +
    expScore*(weights.experience/100) +
    achScore*(weights.achievements/100) +
    eduScore*(weights.education/100) +
    locScore*(weights.location_auth/100) +
    salScore*(weights.salary_availability/100);

  // KO if missing any must-have
  const missing = must.filter((m:string)=>!skills.has(m));
  const is_ko = missing.length>0 && (role.knockouts||[]).includes("missing_must_have");

  return {
    score_total: Math.round(total),
    score_breakdown: {
      skills: Math.round(skillsScore),
      experience: Math.round(expScore),
      achievements: Math.round(achScore),
      education: Math.round(eduScore),
      location_auth: Math.round(locScore),
      salary_availability: Math.round(salScore)
    },
    must_haves_satisfied: haveMust,
    missing_must_haves: missing,
    knockout: { is_ko, reasons: is_ko ? ["Missing required skills"] : [] },
    reasons: [
      `${haveMust.length}/${must.length} must-haves present`,
      `~${expYears} yrs relevant experience`,
      `${achCount} quantified achievements detected`
    ],
    flags: { red: [], yellow: missing.length ? ["Missing some must-haves"] : [] }
  };
}

function estimateYears(exps:any[]) {
  // very rough: count roles, assume ~1.5y each if no dates
  if (!exps.length) return 0;
  const dated = exps.filter(e=>e.start_date||e.end_date);
  if (!dated.length) return Math.min(10, exps.length*1.5);
  // better parsing left out for brevity
  return Math.min(20, dated.length*1.8);
}
