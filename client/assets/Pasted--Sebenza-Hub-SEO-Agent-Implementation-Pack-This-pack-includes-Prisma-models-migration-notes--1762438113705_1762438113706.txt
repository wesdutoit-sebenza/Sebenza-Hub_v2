# Sebenza Hub — SEO Agent Implementation Pack

This pack includes: Prisma models & migration notes, API routes (Next.js App Router), a robust validator, a JSON‑LD fixer, and a ready‑to‑drop React panel for the Job Postings screen.

---

## 1) Prisma schema (additions)

Add to `prisma/schema.prisma` and run migration (notes below):

```prisma
model JobPosting {
  id              String   @id @default(cuid())
  title           String
  location        String
  seniority       String
  summary         String
  // ...your existing fields

  seo             JobSEO?
}

model JobSEO {
  id                   String   @id @default(cuid())
  jobId                String   @unique
  slug                 String   @unique
  titleTag             String   @db.VarChar(70)
  metaDescription      String   @db.VarChar(200)
  ogTitle              String   @db.VarChar(80)
  ogDescription        String   @db.VarChar(220)
  twitterTitle         String   @db.VarChar(80)
  twitterDescription   String   @db.VarChar(220)
  imageAlt             String   @db.VarChar(140)
  keywords             String[]
  hashtags             String[]
  internalLinks        Json
  faq                  Json
  jsonld               String   // JSON-LD as string
  version              Int      @default(1)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  job                  JobPosting @relation(fields: [jobId], references: [id])
}

/// Optional: useful for searching
index JobSEO_slug_lower_idx (slug)
```

### Migration notes

From your repo root:

```bash
npx prisma generate
npx prisma migrate dev --name add_job_seo
```

If using Neon: ensure `extensions = ["pg_trgm"]` are enabled if you later add trigram search; not required for the above.

---

## 2) API: OpenAI client helper

Create `lib/ai.ts`:

```ts
// lib/ai.ts
import OpenAI from "openai";

export const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

export async function generateSEOFromJob(jobJson: any) {
  const system = `You are an SEO assistant for a South African recruiting platform. Return a single JSON object with keys: slug, title_tag, meta_description, og_title, og_description, twitter_title, twitter_description, image_alt, keywords, hashtags, internal_links, faq, jsonld_jobposting. Rules: title_tag<=60, meta_description<=155, og/twitter titles<=70, descriptions<=200, image_alt<=110; slug kebab-case; SA context; valid schema.org JobPosting JSON-LD string using ZAR, ISO dates, employmentType, hiringOrganization, jobLocation (city+country), baseSalary (if present), datePosted (UTC ISO), and valid application URL.`;

  const user = `INPUT JOB JSON\n${JSON.stringify(jobJson, null, 2)}\nOUTPUT: JSON ONLY.`;

  const resp = await openai.chat.completions.create({
    model: "gpt-5", // set via env/config if you prefer
    response_format: { type: "json_object" },
    messages: [
      { role: "system", content: system },
      { role: "user", content: user }
    ],
    temperature: 0.4,
  });

  return JSON.parse(resp.choices[0].message.content || "{}");
}
```

---

## 3) API: Validator & utilities

Create `lib/seo-validator.ts`:

```ts
// lib/seo-validator.ts
import type { PrismaClient } from "@prisma/client";

const MAX = {
  title: 60,
  meta: 155,
  ogTitle: 70,
  ogDesc: 200,
  twTitle: 70,
  twDesc: 200,
  alt: 110,
};

const EMOJI_REGEX = /\p{Extended_Pictographic}/u;
const MULTISPACE = /\s{2,}/g;
const PII = /(\+?\d{2,}[\s-]?)?\d{3}[\s-]?\d{3,}|@|https?:\/\//i; // basic phone/email/url guard

const PROFANITY = ["damn", "hell"];// extend via external list

export function kebab(str: string) {
  return str
    .toLowerCase()
    .replace(/&/g, " and ")
    .replace(/[^a-z0-9\s-]/g, "")
    .replace(/\s+/g, "-")
    .replace(/-+/g, "-")
    .replace(/^-|-$/g, "");
}

function clamp(s: string, n: number) {
  if (!s) return s;
  if (s.length <= n) return s;
  return s.slice(0, n - 1).trimEnd() + "…";
}

function sanitize(s: string) {
  if (!s) return s;
  let t = s.replace(EMOJI_REGEX, "").replace(MULTISPACE, " ").trim();
  // remove quotes that break HTML/meta sometimes
  t = t.replace(/[\u201C\u201D]/g, '"').replace(/[\u2018\u2019]/g, "'");
  return t;
}

function containsPII(s: string) { return PII.test(s || ""); }
function containsProfanity(s: string) {
  const low = (s || "").toLowerCase();
  return PROFANITY.some(w => low.includes(w));
}

export async function ensureUniqueSlug(prisma: PrismaClient, base: string) {
  let slug = base;
  let i = 0;
  while (true) {
    const exists = await prisma.jobSEO.findUnique({ where: { slug } });
    if (!exists) return slug;
    i += 1;
    slug = `${base}-ref${i}`;
  }
}

export function fixJsonLd(jsonld: any, job: any) {
  // If model returns invalid string, rebuild minimal valid JSON-LD
  try {
    const parsed = typeof jsonld === 'string' ? JSON.parse(jsonld) : jsonld;
    if (parsed && parsed['@type'] === 'JobPosting') return JSON.stringify(parsed);
  } catch {}

  const now = new Date().toISOString();
  const salary = job?.salary ? {
    "@type": "MonetaryAmount",
    currency: "ZAR",
    value: { "@type": "QuantitativeValue", value: job.salary }
  } : undefined;

  const base = {
    "@context": "https://schema.org",
    "@type": "JobPosting",
    title: job?.title,
    description: job?.summary,
    datePosted: now,
    employmentType: job?.employmentType || job?.type || "FULL_TIME",
    hiringOrganization: {
      "@type": "Organization",
      name: job?.agency || "Ubuntu Executive Search",
      sameAs: job?.companyUrl || undefined,
    },
    jobLocation: {
      "@type": "Place",
      address: {
        "@type": "PostalAddress",
        addressLocality: job?.location,
        addressCountry: "ZA",
      }
    },
    baseSalary: salary,
    applicantLocationRequirements: {
      "@type": "Country",
      name: "South Africa"
    },
    url: job?.applicationUrl || `https://sebenzahub.co.za/jobs`,
  };
  return JSON.stringify(base);
}

export function cleanAndClampPayload(p: any) {
  const out = { ...p };
  out.title_tag = clamp(sanitize(out.title_tag), MAX.title);
  out.meta_description = clamp(sanitize(out.meta_description), MAX.meta);
  out.og_title = clamp(sanitize(out.og_title), MAX.ogTitle);
  out.og_description = clamp(sanitize(out.og_description), MAX.ogDesc);
  out.twitter_title = clamp(sanitize(out.twitter_title), MAX.twTitle);
  out.twitter_description = clamp(sanitize(out.twitter_description), MAX.twDesc);
  out.image_alt = clamp(sanitize(out.image_alt), MAX.alt);

  // Remove PII & profanity placeholders
  [
    'title_tag','meta_description','og_title','og_description',
    'twitter_title','twitter_description','image_alt'
  ].forEach(k => {
    if (containsPII(out[k]||"")) out[k] = out[k].replace(PII, "").trim();
    if (containsProfanity(out[k]||"")) out[k] = out[k].replace(/\b(hell|damn)\b/gi, "");
  });

  // keywords/hashtags normalization
  out.keywords = Array.isArray(out.keywords) ? Array.from(new Set(out.keywords.map((s:string)=>sanitize(s).toLowerCase()).filter(Boolean))) : [];
  out.hashtags = Array.isArray(out.hashtags) ? Array.from(new Set(out.hashtags.map((s:string)=> s.startsWith('#')? s : `#${s}`))) : [];

  // internal links default
  if (!Array.isArray(out.internal_links)) out.internal_links = [
    { label: "More jobs in South Africa", href: "/jobs" }
  ];

  return out;
}
```

---

## 4) API routes (Next.js App Router)

Create `app/api/seo/generate/route.ts`:

```ts
// app/api/seo/generate/route.ts
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { generateSEOFromJob } from '@/lib/ai';
import { kebab, ensureUniqueSlug, cleanAndClampPayload, fixJsonLd } from '@/lib/seo-validator';

const prisma = new PrismaClient();

export async function POST(req: Request) {
  try {
    const { jobId } = await req.json();
    if (!jobId) return NextResponse.json({ error: 'jobId required' }, { status: 400 });

    const job = await prisma.jobPosting.findUnique({ where: { id: jobId } });
    if (!job) return NextResponse.json({ error: 'Job not found' }, { status: 404 });

    // Compose job JSON for the model
    const jobJson = {
      title: job.title,
      location: job.location,
      seniority: job.seniority,
      summary: job.summary,
      agency: 'Ubuntu Executive Search',
      applicationUrl: `https://sebenzahub.co.za/jobs/${jobId}`,
      // include more fields as needed: salary, employmentType, responsibilities, skills, etc.
    };

    const raw = await generateSEOFromJob(jobJson);

    // Build/repair slug & JSON-LD
    const baseSlug = kebab(`${job.title} ${job.location}`);
    const uniqueSlug = await ensureUniqueSlug(prisma as any, raw.slug ? kebab(raw.slug) : baseSlug);

    const cleaned = cleanAndClampPayload({ ...raw, slug: uniqueSlug });
    cleaned.jsonld_jobposting = fixJsonLd(cleaned.jsonld_jobposting, jobJson);

    // Persist
    const saved = await prisma.jobSEO.upsert({
      where: { jobId },
      create: {
        jobId,
        slug: cleaned.slug,
        titleTag: cleaned.title_tag,
        metaDescription: cleaned.meta_description,
        ogTitle: cleaned.og_title,
        ogDescription: cleaned.og_description,
        twitterTitle: cleaned.twitter_title,
        twitterDescription: cleaned.twitter_description,
        imageAlt: cleaned.image_alt,
        keywords: cleaned.keywords,
        hashtags: cleaned.hashtags,
        internalLinks: cleaned.internal_links,
        faq: cleaned.faq,
        jsonld: cleaned.jsonld_jobposting,
      },
      update: {
        slug: cleaned.slug,
        titleTag: cleaned.title_tag,
        metaDescription: cleaned.meta_description,
        ogTitle: cleaned.og_title,
        ogDescription: cleaned.og_description,
        twitterTitle: cleaned.twitter_title,
        twitterDescription: cleaned.twitter_description,
        imageAlt: cleaned.image_alt,
        keywords: cleaned.keywords,
        hashtags: cleaned.hashtags,
        internalLinks: cleaned.internal_links,
        faq: cleaned.faq,
        jsonld: cleaned.jsonld_jobposting,
        version: { increment: 1 },
      }
    });

    return NextResponse.json({
      slug: saved.slug,
      title_tag: saved.titleTag,
      meta_description: saved.metaDescription,
      og_title: saved.ogTitle,
      og_description: saved.ogDescription,
      twitter_title: saved.twitterTitle,
      twitter_description: saved.twitterDescription,
      image_alt: saved.imageAlt,
      keywords: saved.keywords,
      hashtags: saved.hashtags,
      internal_links: saved.internalLinks,
      faq: saved.faq,
      jsonld_jobposting: saved.jsonld,
      version: saved.version,
    });
  } catch (e:any) {
    console.error(e);
    return NextResponse.json({ error: e.message || 'Internal error' }, { status: 500 });
  }
}
```

Create `app/api/seo/save/route.ts` (for manual edits from UI):

```ts
// app/api/seo/save/route.ts
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { cleanAndClampPayload, kebab, ensureUniqueSlug, fixJsonLd } from '@/lib/seo-validator';

const prisma = new PrismaClient();

export async function POST(req: Request) {
  try {
    const { jobId, seo } = await req.json();
    if (!jobId || !seo) return NextResponse.json({ error: 'jobId and seo required' }, { status: 400 });

    const job = await prisma.jobPosting.findUnique({ where: { id: jobId } });
    if (!job) return NextResponse.json({ error: 'Job not found' }, { status: 404 });

    const cleaned = cleanAndClampPayload(seo);

    // Ensure slug uniqueness if user edited it
    if (cleaned.slug) cleaned.slug = await ensureUniqueSlug(prisma as any, kebab(cleaned.slug));

    cleaned.jsonld_jobposting = fixJsonLd(cleaned.jsonld_jobposting, {
      title: job.title, summary: job.summary, location: job.location,
      agency: 'Ubuntu Executive Search', applicationUrl: `https://sebenzahub.co.za/jobs/${jobId}`
    });

    const saved = await prisma.jobSEO.upsert({
      where: { jobId },
      create: {
        jobId,
        slug: cleaned.slug,
        titleTag: cleaned.title_tag,
        metaDescription: cleaned.meta_description,
        ogTitle: cleaned.og_title,
        ogDescription: cleaned.og_description,
        twitterTitle: cleaned.twitter_title,
        twitterDescription: cleaned.twitter_description,
        imageAlt: cleaned.image_alt,
        keywords: cleaned.keywords,
        hashtags: cleaned.hashtags,
        internalLinks: cleaned.internal_links,
        faq: cleaned.faq,
        jsonld: cleaned.jsonld_jobposting,
      },
      update: {
        slug: cleaned.slug,
        titleTag: cleaned.title_tag,
        metaDescription: cleaned.meta_description,
        ogTitle: cleaned.og_title,
        ogDescription: cleaned.og_description,
        twitterTitle: cleaned.twitter_title,
        twitterDescription: cleaned.twitter_description,
        imageAlt: cleaned.image_alt,
        keywords: cleaned.keywords,
        hashtags: cleaned.hashtags,
        internalLinks: cleaned.internal_links,
        faq: cleaned.faq,
        jsonld: cleaned.jsonld_jobposting,
        version: { increment: 1 },
      }
    });

    return NextResponse.json({ ok: true, version: saved.version });
  } catch (e:any) {
    console.error(e);
    return NextResponse.json({ error: e.message || 'Internal error' }, { status: 500 });
  }
}
```

> If you’re on Express instead of Next App Router, let me know — I’ll add an `express.Router()` version (the service logic is the same).

---

## 5) React: Job Postings — SEO Panel

Create `components/SeoAssistantPanel.tsx`:

```tsx
import { useState } from 'react';

type SEO = {
  slug: string;
  title_tag: string; meta_description: string;
  og_title: string; og_description: string;
  twitter_title: string; twitter_description: string;
  image_alt: string; keywords: string[]; hashtags: string[];
  internal_links: { label: string; href: string;}[];
  faq: { q: string; a: string;}[];
  jsonld_jobposting: string;
  version?: number;
};

function Counter({ value, max }:{ value: string; max: number; }){
  return (
    <div className={`text-xs ${value.length<=max? 'text-green-500':'text-red-500'}`}>{value.length}/{max}</div>
  );
}

function Field({label,value,onChange,max}:{label:string; value:string; onChange:(v:string)=>void; max:number;}){
  return (
    <div className="space-y-1">
      <label className="text-sm font-medium">{label}</label>
      <input className="w-full rounded-xl border p-2 bg-neutral-900" value={value} onChange={e=>onChange(e.target.value)} />
      <Counter value={value} max={max} />
    </div>
  );
}

export default function SeoAssistantPanel({ jobId }:{ jobId: string }){
  const [seo, setSeo] = useState<SEO | null>(null);
  const [locked, setLocked] = useState(false);
  const [busy, setBusy] = useState(false);

  async function generate(){
    setBusy(true);
    try{
      const r = await fetch('/api/seo/generate', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ jobId })});
      const data = await r.json();
      setSeo(data);
    } finally{ setBusy(false); }
  }

  async function save(){
    if(!seo) return;
    setBusy(true);
    try{
      await fetch('/api/seo/save', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ jobId, seo })});
    } finally{ setBusy(false); }
  }

  return (
    <div className="space-y-4">
      <div className="flex items-center gap-2">
        <button disabled={busy} className="btn btn-primary" onClick={generate}>{seo? 'Regenerate':'Generate'}</button>
        <label className="flex items-center gap-2 text-sm"><input type="checkbox" checked={locked} onChange={e=>setLocked(e.target.checked)} />Lock</label>
      </div>

      {seo && (
        <>
          {/* SERP preview */}
          <div className="rounded-2xl p-4 bg-neutral-950 text-sm">
            <div className="text-blue-400 truncate">{seo.title_tag}</div>
            <div className="text-green-500 text-xs">sebenzahub.co.za/jobs/{seo.slug}</div>
            <div className="text-neutral-300">{seo.meta_description}</div>
          </div>

          <Field label="Title Tag" value={seo.title_tag} max={60} onChange={v=> setSeo({ ...seo, title_tag:v })} />
          <Field label="Meta Description" value={seo.meta_description} max={155} onChange={v=> setSeo({ ...seo, meta_description:v })} />
          <Field label="OG Title" value={seo.og_title} max={70} onChange={v=> setSeo({ ...seo, og_title:v })} />
          <Field label="OG Description" value={seo.og_description} max={200} onChange={v=> setSeo({ ...seo, og_description:v })} />
          <Field label="Twitter Title" value={seo.twitter_title} max={70} onChange={v=> setSeo({ ...seo, twitter_title:v })} />
          <Field label="Twitter Description" value={seo.twitter_description} max={200} onChange={v=> setSeo({ ...seo, twitter_description:v })} />
          <Field label="Image Alt" value={seo.image_alt} max={110} onChange={v=> setSeo({ ...seo, image_alt:v })} />

          <div className="flex gap-2">
            <button disabled={busy} className="btn btn-success" onClick={save}>Apply to post</button>
          </div>
        </>
      )}
    </div>
  );
}
```

> Mount this panel in your Job Postings screen (e.g., as a right‑side tab). Pass the current `jobId`.

---

## 6) Rendering on the Job page (SSR)

In your job page server component/`getServerSideProps`, fetch `JobSEO` and inject into `<head>`:

```tsx
// Example (Next.js App Router server component)
import { PrismaClient } from '@prisma/client';

export async function generateMetadata({ params }: { params: { slug: string }}) {
  const prisma = new PrismaClient();
  const seo = await prisma.jobSEO.findUnique({ where: { slug: params.slug }});
  if (!seo) return { title: 'Jobs | Sebenza Hub' };

  return {
    title: seo.titleTag,
    description: seo.metaDescription,
    alternates: { canonical: `/jobs/${seo.slug}` },
    openGraph: { title: seo.ogTitle, description: seo.ogDescription },
    twitter: { title: seo.twitterTitle, description: seo.twitterDescription },
  };
}

export default async function JobPage({ params }:{ params:{ slug:string }}){
  const prisma = new PrismaClient();
  const job = await prisma.jobPosting.findFirst({ where: { seo: { slug: params.slug }}, include: { seo: true }});
  if (!job) return <div>Not found</div>;

  return (
    <>
      <script type="application/ld+json" dangerouslySetInnerHTML={{ __html: job.seo?.jsonld || '' }} />
      {/* ...your job page UI... */}
    </>
  );
}
```

---

## 7) Environment variables

```
OPENAI_API_KEY=sk-...
```

If you proxy via your own function or use another provider, swap the `lib/ai.ts` client accordingly.

---

## 8) Optional extras

* **A/B test**: store `variant` in `JobSEO` and rotate titles; log CTR from GA4.
* **Sitemaps**: add `/sitemap_jobs.xml` that queries `JobSEO.slug` with `updatedAt` as `lastmod`.
* **Auto‑toast**: watch for changes in job title/location; if `!locked`, prompt regenerate.
* **SA localisation**: use “organisation”, “centre”, etc. in prompts.

---

## 9) Quick checklist

* [ ] Run Prisma migration
* [ ] Set `OPENAI_API_KEY`
* [ ] Add API routes + validator
* [ ] Mount `SeoAssistantPanel` on Job Postings
* [ ] Inject head tags + JSON‑LD on job page
* [ ] Add sitemap job URLs

---

**Done.** Paste these files into your repo and it should work out of the box with minimal tweaks to your existing JobPosting model and UI.
