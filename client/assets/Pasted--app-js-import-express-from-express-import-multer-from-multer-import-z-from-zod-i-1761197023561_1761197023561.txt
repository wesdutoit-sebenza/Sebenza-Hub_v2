// app.js
import express from "express";
import multer from "multer";
import { z } from "zod";
import { OpenAI } from "openai";
import fs from "fs/promises";
import path from "path";
import pg from "pg";

const app = express();
const upload = multer({ dest: "uploads/" });
app.use(express.json({ limit: "10mb" }));

// ---- env ----
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const pool = new pg.Pool({ connectionString: process.env.DATABASE_URL });

// Validate agent output
const CvSchema = z.object({
  source_meta: z.object({
    filename: z.string(),
    filesize_bytes: z.number(),
    parsed_ok: z.boolean(),
    parse_notes: z.string().nullable().optional()
  }),
  candidate: z.object({
    full_name: z.string().nullable().optional(),
    headline: z.string().nullable().optional(),
    contact: z.object({
      email: z.string().nullable().optional(),
      phone: z.string().nullable().optional(),
      city: z.string().nullable().optional(),
      country: z.string().nullable().optional()
    }),
    links: z.object({
      linkedin: z.string().nullable().optional(),
      portfolio: z.string().nullable().optional(),
      github: z.string().nullable().optional(),
      other: z.string().nullable().optional()
    }).partial(),
    summary: z.string().nullable().optional(),
    skills: z.object({
      technical: z.array(z.string()).default([]),
      tools: z.array(z.string()).default([]),
      soft: z.array(z.string()).default([])
    }),
    experience: z.array(z.object({
      title: z.string().nullable().optional(),
      company: z.string().nullable().optional(),
      industry: z.string().nullable().optional(),
      location: z.string().nullable().optional(),
      start_date: z.string().nullable().optional(),
      end_date: z.string().nullable().optional(),
      is_current: z.boolean().nullable().optional(),
      bullets: z.array(z.string()).default([])
    })).default([]),
    education: z.array(z.object({
      institution: z.string().nullable().optional(),
      qualification: z.string().nullable().optional(),
      location: z.string().nullable().optional(),
      grad_date: z.string().nullable().optional()
    })).default([]),
    certifications: z.array(z.object({
      name: z.string().nullable().optional(),
      issuer: z.string().nullable().optional(),
      year: z.string().nullable().optional()
    })).default([]),
    projects: z.array(z.object({
      name: z.string().nullable().optional(),
      what: z.string().nullable().optional(),
      impact: z.string().nullable().optional(),
      link: z.string().nullable().optional()
    })).default([]),
    awards: z.array(z.object({
      name: z.string().nullable().optional(),
      by: z.string().nullable().optional(),
      year: z.string().nullable().optional(),
      note: z.string().nullable().optional()
    })).default([]),
    work_authorization: z.string().nullable().optional(),
    availability: z.string().nullable().optional(),
    salary_expectation: z.string().nullable().optional(),
    notes: z.string().nullable().optional()
  })
});

// Util: upsert skill and link
async function addSkills(client, candidateId, names, kind) {
  for (const raw of (names || [])) {
    const name = raw?.trim();
    if (!name) continue;
    const { rows: s1 } = await client.query(
      "INSERT INTO skills(name) VALUES($1) ON CONFLICT(name) DO UPDATE SET name=EXCLUDED.name RETURNING id",
      [name]
    );
    const skillId = s1[0].id;
    await client.query(
      "INSERT INTO candidate_skills(candidate_id, skill_id, kind) VALUES($1,$2,$3) ON CONFLICT DO NOTHING",
      [candidateId, skillId, kind]
    );
  }
}

// Endpoint: upload & parse a CV file
app.post("/ingest/cv", upload.single("file"), async (req, res) => {
  const file = req.file;
  if (!file) return res.status(400).json({ error: "No file uploaded" });

  try {
    // Read text (for PDFs/DOCs you can start with raw bytes; here we pass the file to the LLM as-is)
    const fileBytes = await fs.readFile(file.path);

    // Call your “CV Ingestion Agent” system prompt here
    const systemPrompt = process.env.CV_INGEST_SYSTEM_PROMPT; // paste the prompt above into this env var
    const userPrompt = `Parse this CV and return OUTPUT_SCHEMA JSON only. Filename=${file.originalname}, size=${file.size} bytes.`;

    const completion = await openai.chat.completions.create({
      model: "gpt-5.1-mini", // or your chosen model
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userPrompt },
        // Some SDKs support file as separate param; if not, embed text or base64.
        // If you have a text extractor, pass extracted text here instead.
        { role: "user", content: fileBytes.toString("base64") }
      ],
      temperature: 0
    });

    const raw = completion.choices[0].message.content;
    const parsed = CvSchema.parse(JSON.parse(raw));

    const client = await pool.connect();
    try {
      await client.query("BEGIN");

      // Insert candidate
      const c = parsed.candidate;
      const contact = c.contact || {};
      const links = c.links || {};
      const { rows: cRes } = await client.query(
        `INSERT INTO candidates(full_name, headline, email, phone, city, country, links, summary, work_authorization, availability, salary_expectation, notes)
         VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12)
         RETURNING id`,
        [
          c.full_name || null, c.headline || null,
          contact.email || null, contact.phone || null,
          contact.city || null, contact.country || null,
          JSON.stringify(links || {}),
          c.summary || null,
          c.work_authorization || null, c.availability || null, c.salary_expectation || null,
          c.notes || null
        ]
      );
      const candidateId = cRes[0].id;

      // Insert resume meta and raw text (optional)
      await client.query(
        `INSERT INTO resumes(candidate_id, filename, filesize_bytes, parsed_ok, parse_notes, raw_text)
         VALUES ($1,$2,$3,$4,$5,$6)`,
        [
          candidateId,
          parsed.source_meta.filename || file.originalname,
          parsed.source_meta.filesize_bytes || file.size,
          parsed.source_meta.parsed_ok ?? true,
          parsed.source_meta.parse_notes || null,
          null // store extracted text if you have it
        ]
      );

      // Experiences
      for (const e of c.experience || []) {
        await client.query(
          `INSERT INTO experiences(candidate_id, title, company, industry, location, start_date, end_date, is_current, bullets)
           VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)`,
          [
            candidateId,
            e.title || null, e.company || null, e.industry || null, e.location || null,
            e.start_date || null, e.end_date || null, e.is_current || false,
            (e.bullets && e.bullets.length ? e.bullets : null)
          ]
        );
      }

      // Education
      for (const ed of c.education || []) {
        await client.query(
          `INSERT INTO education(candidate_id, institution, qualification, location, grad_date)
           VALUES ($1,$2,$3,$4,$5)`,
          [candidateId, ed.institution || null, ed.qualification || null, ed.location || null, ed.grad_date || null]
        );
      }

      // Certifications
      for (const cert of c.certifications || []) {
        await client.query(
          `INSERT INTO certifications(candidate_id, name, issuer, year)
           VALUES ($1,$2,$3,$4)`,
          [candidateId, cert.name || null, cert.issuer || null, cert.year || null]
        );
      }

      // Projects, Awards
      for (const p of c.projects || []) {
        await client.query(
          `INSERT INTO projects(candidate_id, name, what, impact, link)
           VALUES ($1,$2,$3,$4,$5)`,
          [candidateId, p.name || null, p.what || null, p.impact || null, p.link || null]
        );
      }
      for (const a of c.awards || []) {
        await client.query(
          `INSERT INTO awards(candidate_id, name, by_whom, year, note)
           VALUES ($1,$2,$3,$4,$5)`,
          [candidateId, a.name || null, a.by || null, a.year || null, a.note || null]
        );
      }

      // Skills
      await addSkills(client, candidateId, c.skills?.technical, "technical");
      await addSkills(client, candidateId, c.skills?.tools, "tools");
      await addSkills(client, candidateId, c.skills?.soft, "soft");

      await client.query("COMMIT");

      res.json({ ok: true, candidate_id: candidateId });
    } catch (e) {
      await client.query("ROLLBACK");
      console.error(e);
      res.status(500).json({ error: "DB transaction failed" });
    } finally {
      client.release();
    }
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Parse failed" });
  } finally {
    // cleanup
    if (req.file) {
      try { await fs.unlink(req.file.path); } catch {}
    }
  }
});

// Health
app.get("/health", (_, res) => res.json({ ok: true }));

app.listen(3000, () => console.log("API listening on :3000"));
